## What is 1DEvol?

1DEvol is  MATLAB package to carry out approximate Hamiltonian evolutions of 1D quantum systems, finite or infinite, through the hierarchy of semidefinite programming relaxations described in the paper [Non-commutative optimization problems with differential constraints](https://arxiv.org/abs/2408.02572).


## Installation

You will need to have the MATLAB package [YALMIP](https://github.com/yalmip/YALMIP) installed in your computer, and also a YALMIP-compatible solver, e.g.: [Mosek](https://www.mosek.com/).

Once this is done, just copy all the files into a folder and add the latter to your MATLAB path.

## The basics

The package 1DEvol defines three main classes: Monomial, Polynomial and Optimization.

### The Monomial class

 This class is used to model monomials of the form 
 
 
 $$\tilde{t}^l\prod_{k=1}^n\tilde{\sigma}^{(k)}_{j_k},$$
 
 
 where $`\tilde{\sigma}^{(k)}_{1}, \tilde{\sigma}^{(k)}_{2},\tilde{\sigma}^{(k)}_{3}`$ represent the three Pauli matrices of qubit $k$ and $`\tilde{\sigma}^{(k)}_{0}=1`$, for all $k$. The parameter $n$, indicating the maximum number of qubits to be used in computations, is immutable. 
 The command `Monomial.local_pauli`($`k_\sigma,k_t, n`$) generates a vector containing all monomials in $`\mathbb{M}^{1D}(k_\sigma,k_t,n)`$.

```
lista_mons=Monomial.local_pauli(1,1, 2)

lista_mons = 

1
\sigma^{(2)}_{1}
\sigma^{(2)}_{2}
\sigma^{(2)}_{3}
\sigma^{(1)}_{1}
\sigma^{(1)}_{2}
\sigma^{(1)}_{3}
t
t\sigma^{(2)}_{1}
t\sigma^{(2)}_{2}
t\sigma^{(2)}_{3}
t\sigma^{(1)}_{1}
t\sigma^{(1)}_{2}
t\sigma^{(1)}_{3}
```

The degree of a monomial can be accessed with the function `Monomial.degree`.

```
 lista_mons(10).degree

ans =

     2lista_mons(10).degree
```

The command `Monomial.local'_pauli_squared`$`(k_\sigma,k_t, n)`$ generates the list of monomials that span the polynomials $`\mathbb{M}^{1D}(k_\sigma,k_t,n)^2`$. 
This list is useful, in that it contains all the monomials appearing in the moment matrix with columns labeled by the elements of $`\mathbb{M}^{1D}(k_\sigma,k_t,n)`$.

### The Polynomial class

The elements of $`\tilde{\mathbb{P}}_{[0,1]}`$ are represented through the class `Polynomial`. Each polynomial is specified by a vector of monomials 
`list_mon` and a vector of coefficients `list_coeffs` of the same length. The coefficients can be complex numbers, yalmip variables or both. The class constructor is `Polynomial}(list_coeffs, list_mon)`.
```
random_poly=Polynomial(randn(5,1),lista_mons(1:5))

random_poly = 

+0.53767+1.8339\sigma^{(2)}_{1}-2.2588\sigma^{(2)}_{2}+0.86217\sigma^{(2)}_{3}+0.31877\sigma^{(1)}_{1}
```

One can access the lists of monomials and coefficients of `random_poly` through the properties `list_mon`, `list_coeffs`.

```
random_poly.list_coeffs

ans =

    0.5377    1.8339   -2.2588    0.8622    0.3188
```

The special polynomials $0$, $1$, $\tilde{t}$ and $`\tilde{\sigma}^{(k)}_a`$ are respectively generated by the functions `Polynomial.zero`$`(n)`$, `Polynomial.unit`$`n`$, `Polynomial.time`$`(n)`$, `Polynomial.sigma`$`(a,k,n)`$. 

```
t=Polynomial.time(2)

t = 

+t    

```

```
X1=Polynomial.sigma(1,1,2)

X1 = 

+\sigma^{(1)}_{1}          
```

```

Z2=Polynomial.sigma(3,2,2)

Z2 = 

+\sigma^{(2)}_{3}   
```

Like with the \texttt{Monomial} class, defining instances of \texttt{Polynomial} also requires specifying the maximum number of qubits $n$ to be used in future computations.

One can add and multiply Polynomials by complex numbers, or even other polynomials.

```
poly1=X1+3*Z2-4

poly1 = 

-4+3\sigma^{(2)}_{3}+\sigma^{(1)}_{1}
```

```
poly2=6*X1*Z2

poly2 = 

+6\sigma^{(1)}_{1}\sigma^{(2)}_{3}                
```

```
poly1*poly2^2

ans = 

-144+108\sigma^{(2)}_{3}+36\sigma^{(1)}_{1}  
```


The functions `Polynomial.n`, `Polynomial.degree`, `Polynomial.support`, `Polynomial.sparsity` respectively return the number of qubits for computations, the degree of the polynomial, the subset $`S\subset \{1,...,n\}`$ of qubits that appear in the polynomial and the number of monomials.

The function `Polynomial.translate`$`(p,j)`$ applies the spin-chain translation operator $j$ times to the polynomial $p$.

```
p=Polynomial.sigma(1,1,10)*Polynomial.time(10)+4

p = 
+4+t\sigma^{(1)}_{1}

p.translate(5)

ans =

+4+t\sigma^{(6)}_{1}

```

The function `Polynomial.evaluate(poly1, poly2)` evaluates the Polynomial `poly1` by replacing its monomials with the corresponding coefficients of `poly2`. That is, `poly2` acts as a list of momenta: the monomial `poly2.list\_mon(k)` is understood to have the value `poly2.list_coeff(k)`. Of course, in order to evaluate `poly1` with `poly2`, it is necessary that the list of monomials of `poly2` contains that of `poly1`.


### The Optimization Class

The class `Optimization` handles SDP relaxations over 1D systems. Its constructor requires specifying a Hamiltonian term `h` and an objective function `obj`. Both are understood to be instances of the `Polynomial` class, be Hermitian and have no $\tilde{t}$ terms. In addition, `h` must be a polynomial acting on just the first two qubits, i.e., `isequal(h.support,[1,2])==true`. For $n$=`h.n`, the total Hamiltonian is taken to be:

$$H_n=\sum_{j=0}^{n-1}\mathbb{T}^j(h)$$

if the system is finite, or 

$$H=\sum_{j\in\mathbb{Z}}\mathbb{T}^j(h)$$

if the system is infinite. The objective function expresses which local property of the 1D system we wish to bound.

For instance, the commands

```
X1=Polynomial.sigma(1,1,5); Y2=Polynomial.sigma(2,2,5); Z1=Polynomial.sigma(3,1,5); h=X1*Y2; obj=Z1; optim=Optimization(h, obj);
```  
\noindent define an optimization problem with a Hamiltonian with general term $`h_{j,j+1}=\sigma^{(j)}_1\sigma^{(j+1)}_2`$ and set the magnetization of the first qubit $`\sigma^{(1)}_3`$ to be the objective function.

Note that the instantiation of the \texttt{Optimization} class already has an implicit number of qubits $n$, encoded in the polynomials that make up `h` and `obj`. One can retrieve $n$ through the function `Optimization.n`.

```

optim.n

ans =
5

```

What comes next depends on whether we wish to carry out calculations for finite or infinite systems.


## Estimating local properties of finite quantum 1D systems
Let $v$ be a vector of length $`n=`$`optim.n`, composed of 0s and 1s. If we call the function `Optimization.bounds_open(optim,tau,k_sigma, k_time,v))`, we will obtain lower and upper bounds for the value of the objective function of the $n$-qubit system that, starting in state $`\otimes_{k=1}^n \ket{v(k)}`$, is propagated by the Hamiltonian (\ref{hami_finite}) for time \texttt{tau}. The natural numbers `k_sigma, k_time` respectively denote the parameters $`k_\sigma`$, $`k_t`$ of the SDP relaxation, see [arXiv:2408.02572](https://arxiv.org/abs/2408.02572).

```

[upp, low]=optim.bounds_open(1,2, 2,[0,0,0,1,1])

```

(some Mosek computations later...)

```

upp =
-0.0307

low =
-0.0347

```

If, instead of a real number, `tau` is a * *vector* * of real numbers, then the function returns a list of upper (lower) bounds for each time `tau(k)`.



## Estimating local properties of finite quantum 1D systems
The function `Optimization.bounds(optim,tau,k_sigma, k_time)` has the effect of computing upper and lower bounds on the average value of the operator `optim.obj`, under the assumption that the 1D system, initially prepared in state $`\ket{0}^{\infty}`$, has been subject to the Hamiltonian $H$ for time `tau`. In this case, the parameter `optim.n` does not denote the number of qubits in the system, but the index $n$ of the SDP relaxation, see [arXiv:2408.02572](https://arxiv.org/abs/2408.02572) for details.

```

[upp, low]=optim.bounds(1,2, 2)

```

(some Mosek computations later...)

```


upp =

-0.1087
low =

-0.6973

```



