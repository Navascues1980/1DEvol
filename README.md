## What is 1DEvol?

1DEvol is  MATLAB package to carry out approximate Hamiltonian evolutions of 1D quantum systems, finite or infinite.


## Installation

You will need to have MATLAB and YALMIP \cite{yalmip} installed in your computer, and also a YALMIP-compatible solver, e.g.: Mosek \cite{mosek}.

Once this is done, just uncompress the .zip file, copy the whole folder inside to your hard drive and add the latter to your MATLAB path.

## The basics

The package 1DEvol defines three main classes: Monomial, Polynomial and Optimization.

### The Monomial class

 This class is used to model monomials of the form 
 
 
 $$\tilde{t}^l\prod_{k=1}^n\tilde{\sigma}^{(k)}_{j_k},$$
 
 
 where $`\tilde{\sigma}^{(k)}_{1}, \tilde{\sigma}^{(k)}_{2},\tilde{\sigma}^{(k)}_{3}`$ represent the three Pauli matrices of qubit $k$ and $`\tilde{\sigma}^{(k)}_{0}=1`$, for all $k$. The parameter $n$, indicating the maximum number of qubits to be used in computations, is immutable. 
 The command `Monomial.local_pauli`($`k_\sigma,k_t, n`$) generates a vector containing all monomials in $`\mathbb{M}^{1D}(k_\sigma,k_t,n)`$.

```
lista_mons=Monomial.local_pauli(1,1, 2)

lista_mons = 

1
\sigma^{(2)}_{1}
\sigma^{(2)}_{2}
\sigma^{(2)}_{3}
\sigma^{(1)}_{1}
\sigma^{(1)}_{2}
\sigma^{(1)}_{3}
t
t\sigma^{(2)}_{1}
t\sigma^{(2)}_{2}
t\sigma^{(2)}_{3}
t\sigma^{(1)}_{1}
t\sigma^{(1)}_{2}
t\sigma^{(1)}_{3}
```

The degree of a monomial can be accessed with the function `Monomial.degree`.

```
 lista_mons(10).degree

ans =

     2lista_mons(10).degree
```

The command `Monomial.local'_pauli_squared`$`(k_\sigma,k_t, n)`$ generates the list of monomials that span the polynomials $`\mathbb{M}^{1D}(k_\sigma,k_t,n)^2`$. 
This list is useful, in that it contains all the monomials appearing in the moment matrix with columns labeled by the elements of $`\mathbb{M}^{1D}(k_\sigma,k_t,n)`$.

### The Polynomial class

The elements of $`\tilde{\mathbb{P}}_{[0,1]}`$ are represented through the class `Polynomial`. Each polynomial is specified by a vector of monomials 
`list_mon` and a vector of coefficients `list_coeffs` of the same length. The coefficients can be complex numbers, yalmip variables or both. The class constructor is `Polynomial}(list_coeffs, list_mon)`.
```
random_poly=Polynomial(randn(5,1),lista_mons(1:5))

random_poly = 

+0.53767+1.8339\sigma^{(2)}_{1}-2.2588\sigma^{(2)}_{2}+0.86217\sigma^{(2)}_{3}+0.31877\sigma^{(1)}_{1}
```

One can access the lists of monomials and coefficients of `random_poly` through the properties `list_mon`, `list_coeffs`.

```
random_poly.list_coeffs

ans =

    0.5377    1.8339   -2.2588    0.8622    0.3188
```

The special polynomials $0$, $1$, $\tilde{t}$ and $`\tilde{\sigma}^{(k)}_a`$ are respectively generated by the functions `Polynomial.zero`$`(n)`$, `Polynomial.unit`$`n`$, `Polynomial.time`$`(n)`$, `Polynomial.sigma`$`(a,k,n)`$. 

```
t=Polynomial.time(2)

t = 

+t    

```

```
X1=Polynomial.sigma(1,1,2)

X1 = 

+\sigma^{(1)}_{1}          
```

```

Z2=Polynomial.sigma(3,2,2)

Z2 = 

+\sigma^{(2)}_{3}   
```

Like with the \texttt{Monomial} class, defining instances of \texttt{Polynomial} also requires specifying the maximum number of qubits $n$ to be used in future computations.

One can add and multiply Polynomials by complex numbers, or even other polynomials.

```
poly1=X1+3*Z2-4

poly1 = 

-4+3\sigma^{(2)}_{3}+\sigma^{(1)}_{1}
```

```
poly2=6*X1*Z2

poly2 = 

+6\sigma^{(1)}_{1}\sigma^{(2)}_{3}                
```

```
poly1*poly2^2

ans = 

-144+108\sigma^{(2)}_{3}+36\sigma^{(1)}_{1}  
```


The functions \texttt{Polynomial.n}, \texttt{Polynomial.degree}, \texttt{Polynomial.support}, \texttt{Polynomial.sparsity} respectively return the number of qubits for computations, the degree of the polynomial, the subset $S\subset \{1,...,n\}$ of qubits that appear in the polynomial and the number of monomials.

The function \texttt{Polynomial.translate}$(p,j)$ applies the spin-chain translation operator $j$ times to the polynomial $p$.

\vspace{10pt}

\noindent\texttt{p=Polynomial.sigma(1,1,10)*Polynomial.time(10)+4}

\vspace{10pt}

\noindent\textbf{p = \\ \\+4+t$\backslash$sigma\^{}\{(1)\}\_\{1\}}

\vspace{10pt}

\noindent\texttt{p.translate(5)}

\vspace{10pt}

\noindent\textbf{ans = \\ \\+4+t$\backslash$sigma\^{}\{(6)\}\_\{1\}}

\vspace{10pt}

The function \texttt{Polynomial.evaluate(poly1, poly2)} evaluates the Polynomial \texttt{poly1} by replacing its monomials with the corresponding coefficients of \texttt{poly2}. That is, \texttt{poly2} acts as a list of momenta: the monomial \texttt{poly2.list\_mon(k)} is understood to have value \texttt{poly2.list\_coeff(k)}. Of course, in order to evaluate \texttt{poly1} with \texttt{poly2}, it is necessary that the list of monomials of \texttt{poly2} contains that of \texttt{poly1}.

%The command \texttt{Polynomial.double(poly)} replaces the YALMIP coefficients of poly by their values after an optimization. The new polynomial can then be used to evaluate other polynomials through function \texttt{Polynomial.evaluate}.

\section{The Optimization Class}
The class \texttt{Optimization} handles SDP relaxations over 1D systems. Its constructor requires specifying a Hamiltonian term \texttt{h} and an objective function \texttt{obj}. Both are understood to be instances of the \texttt{Polynomial} class, be Hermitian and have no $\tilde{t}$ terms. In addition, \texttt{h} must be a polynomial acting on just the first two qubits, i.e., \texttt{h.support==[1,2]}. For $n$=\texttt{h.n}, the total Hamiltonian is taken to be:
\begin{equation}
H=\sum_{j=0}^{n-1}\mathbb{T}^j(h)
\label{hami_finite}
\end{equation}
if the system is finite, or 
\begin{equation}
H=\sum_{j\in\mathbb{Z}}\mathbb{T}^j(h)
\label{hami_infinite}
\end{equation}
if the system is infinite. The objective function expresses which local property of the 1D system we wish to bound.

For instance, the commands
\vspace{10pt}

\noindent\texttt{X1=Polynomial.sigma(1,1,5); Y2=Polynomial.sigma(2,2,5); Z1=Polynomial.sigma(3,1,5); h=X1*Y2; obj=Z1; optim=Optimization(h, obj);}

\vspace{10pt}
\noindent define an optimization problem with a Hamiltonian with general term $h_{j,j+1}=\sigma^{(j)}_1\sigma^{(j+1)}_2$ and set the magnetization of the first qubit $\sigma^{(1)}_3$ to be the objective function.

Note that the instantiation of the \texttt{Optimization} class already has an implicit number of qubits $n$, encoded in the polynomials that make up \texttt{h} and \texttt{obj}. One can retrieve $n$ through the function \texttt{Optimization.n}.

\vspace{10pt}

\noindent\texttt{optim.n}

\vspace{10pt}

\noindent\textbf{ans = \\ \\5}

\vspace{10pt}



What comes next depends on whether we wish to carry out calculations for finite or infinite systems.

\subsection{Finite systems}
Let $v$ be a vector of length $n=$\texttt{optim.n}, composed of 0s and 1s. If we call the function 
\begin{center}
\texttt{Optimization.bounds\_open(optim,tau,k\_sigma, k\_time,v))},     
\end{center}
\noindent we will obtain lower and upper bounds for the value of the objective function of the $n$-qubit system that, starting in state $\otimes_{k=1}^n \ket{v(k)}$, is propagated by the Hamiltonian (\ref{hami_finite}) for time \texttt{tau}. The natural numbers \texttt{k\_sigma, k\_time} respectively denote the parameters $k_\sigma$, $k_t$ of the SDP relaxation, see the main text.

\vspace{10pt}

\noindent\texttt{[upp, low]=optim.bounds\_open(1,2, 2,[0,0,0,1,1])}

\vspace{10pt}

(some Mosek computations later...)

\vspace{10pt}

\noindent\textbf{upp =\\ \\-0.0307\\ \\low = \\ \\-0.0347}

\vspace{10pt}

If, instead of a real number, \texttt{tau} is a vector of real numbers, then the function returns a list of upper (lower) bounds for each time \texttt{tau(k)}.



\subsection{Infinite systems}
The function \texttt{Optimization.bounds(optim,tau,k\_sigma, k\_time)} has the effect of computing upper and lower bounds on the average value of the operator \texttt{optim.obj}, under the assumption that the system, initially prepared in state $\ket{0}^{\infty}$, has been subject to the Hamiltonian (\ref{hami_infinite}) for time \texttt{tau}. In this case, the parameter \texttt{optim.n} does not denote the number of qubits of the system, but the index $n$ of the corresponding SDP relaxation, see the main text.

\vspace{10pt}

\noindent\texttt{[upp, low]=optim.bounds(1,2, 2)}

\vspace{10pt}

(some Mosek computations later...)

\vspace{10pt}


\noindent\textbf{upp =\\ \\-0.1087\\low =\\ \\-0.6973}

\vspace{10pt}



